-- SRB2 Lua Script
-- classic.wad/LUA_CLAS  -- Implement classic games' behavior.
--
-- Written by Rumia (rumia1)
-- Optimizations and additions by James (jameds)
-- Last modified: 21 December 2017
--
-- This file is placed in the public domain.
--
-- CREDITS: Rapidgame7 for slope detection.


-------------------------------------------------------------------------------

freeslot("S_SPINDASH1", "SPR_SPIN")
freeslot("sfx_rev1", "sfx_rev2", "sfx_rev3", "sfx_rev4",
         "sfx_rev5", "sfx_rev6", "sfx_rev7")

local REVSOUNDS = { sfx_rev1, sfx_rev2, sfx_rev3, sfx_rev4,
                    sfx_rev5, sfx_rev6, sfx_rev7 }

local MENU_FADEIN, MENU_FADEOUT = 2, 3
local FADETICS = 12

local cv_classic
local cv_camadjust  -- slope camera
local cv_menukey, cv_menuhold, cv_menurepeat
-- subsystems
local cv_momentum
local cv_nothok,     cv_spincharge, cv_droproll
local cv_animations, cv_fancyrev,   cv_walkspring

-- Default values for skins.
rawset(_G, "classic",
{
	sonic    = { nothok = true },
	tails    = {},
	knuckles = {},

	amy         = { droproll = false },
	metal_sonic = { fancyrev = false, spincharge = false },
	shadow      = { fancyrev = false },
	fsonic      = { fancyrev = false },
	silver      = { fancyrev = false, droproll = false },
	tailscd     = { fancyrev = false },
	dirk        = { fancyrev = false },

	-- Now you're the exception.
	peach        = false, toad    = false,
	samus        = false,
	marisa       = false, alice   = false,
	modernsonic  = false,
	sonicrefancy = false, sonicre = false, tailsre = false, knuxre = false,
	kirby        = false,
	silver       = false,
})


-------------------------------------------------------------------------------

rawset(_G, "V_DrawPatchFill", function (v, pat, flags, c)
	local w, h   = 320, 200
	local pw, ph = pat.width, pat.height

	if (v.renderer() == "software") then  -- weird software bug with trans
		flags = ($ == nil) and V_NOSCALESTART or $|V_NOSCALESTART
		w, h  = v.width(), v.height()

		local dupx = v.dupx()  -- width is always larger in software modes
		local offs = (dupx & (dupx-1)) and 1 or 0  -- non power of two
		pw, ph = $1 * dupx + offs, $2 * dupx + offs
	end

	for x = 0, w, pw do
		for y = 0, h, ph do
			v.draw(x, y, pat, flags, c)
		end
	end
end)


-------------------------------------------------------------------------------

local function setcv (p, cv, n) COM_BufInsertText(p, cv.name .. " " .. n) end
local function range (a, x, y)  return (a >= x and a <= y) end
local function cvor  (cv, n)
	return (cv.value == 1 or (cv.value == 2 and n))
end

local function ClassicSpindash (p)
	if (p.spincharges > 0) then
		-- Making this a little easier on ourselves.
		p.mindash  = p.maxdash
		p.dashtime = 1  -- Cut off rev sound after the first charge.
	end

	-- Someone had the bright idea to make it so none of the
	-- buttons (except use) register during the race countdown.
	if ((gametype == GT_RACE or gametype == GT_COMPETITION)
		 and leveltime < 4*TICRATE)
	then
		p.charability2 = CA2_NONE
	else
		p.charability2 = skins[p.mo.skin].ability2
		if (p.charability2 == CA2_SPINDASH) then
			p.mindash = p.maxdash

			-- You gotta be spindashing, man!
			if (p.pflags & PF_STARTDASH) then
				p.jumpfactor = 0  -- can't charge if we jump

				-- Real rev sound plays once.
				if (p.spincharges == 0) then
					p.mindash = 23*FRACUNIT
					p.maxdash = 25*FRACUNIT
				end

				if (p.cmd.buttons & BT_JUMP and not (p.prevcmd.buttons & BT_JUMP))
				then
					if (p.maxdash < 60*FRACUNIT) then
						p.maxdash = $ + 5*FRACUNIT
					end

					S_StartSound(p.mo, REVSOUNDS[1+p.spincharges])
					if (p.spincharges < 6) then
						p.spincharges = $+1
					end
				end
			else
				p.jumpfactor = skins[p.mo.skin].jumpfactor
				p.spincharges = 0
			end
		end
	end
end

local function ClassicSpindashFrames (p)
	if (p.pflags & PF_STARTDASH) then
		p.mo.state = S_SPINDASH1
		p.panim = PA_ROLL

		p.spindashframe = ($ + 55*FRACUNIT/90) % (4*FRACUNIT)

		for i = 1, 8 do
			local modust = P_SpawnMobj(p.mo.x, p.mo.y,
				p.mo.z +
				((p.mo.eflags & MFE_VERTICALFLIP) and 1 or 0) *
				(p.mo.height - mobjinfo[MT_PARTICLE].height),
				MT_PARTICLE)

			modust.tics       = 8
			modust.eflags     = $|p.mo.eflags & MFE_VERTICALFLIP
			modust.scale      = p.mo.scale >> 1
			modust.destscale  = p.mo.scale << 3
			modust.scalespeed = FixedMul(modust.scalespeed, p.mo.scale)
			P_SetObjectMomZ(modust, FRACUNIT + P_RandomByte() << 10, false)

			P_InstaThrust(modust, p.mo.angle +
				FixedAngle(P_RandomRange(-15, 15)*FRACUNIT),
				-(30*FRACUNIT) / 9)
			P_TryMove(modust, modust.x + modust.momx, modust.y + modust.momy,
			          true)
		end
		p.mo.frame = p.spindashframe/FRACUNIT
	end
end

local function ClassicMomentum (p, onslope)
	p.topspeed = 34*FRACUNIT
	p.maxspeed = 115*FRACUNIT  -- Can't have Sonic zooming at
			                     -- an out-of-control speed.

	if (gametype != GT_COOP and (p.mo.skin == "sonic" or p.mo.skin == "fsonic"))
	then
		p.topspeed = 38*FRACUNIT  -- Sonic gets serious.
	end

	local downslope =
		onslope
		and (p.prevz * P_MobjFlip(p.mo) > p.mo.z * P_MobjFlip(p.mo))
		and p.rspeed >= p.topspeed - 6*FRACUNIT
		and p.rspeed <  p.maxspeed  -- keep control managable

	-- Breaking the vanilla speed cap:
	if (p.rspeed > p.topspeed and not (p.mo.eflags & MFE_JUSTHITFLOOR)
		 and not (p.mo.skin == "dirk" and (p.cmd.buttons & BT_USE)))  -- Ice surf
	then
		if (not (p.powers[pw_sneakers] or p.powers[pw_super])) then
			if (P_IsObjectOnGround(p.mo) and p.rspeed > p.normalspeed) then
				-- Basically accelerate faster with more friction,
				-- and slower with less.
				-- Not realistic, but it works to balance things.
				p.normalspeed = FixedMul($ + p.rspeed - p.topspeed + 15*FRACUNIT/3,
				                         FixedDiv(59392, p.mo.friction))
			elseif (p.rspeed < p.normalspeed - 8*FRACUNIT) then
				p.normalspeed = $ - 5*FRACUNIT
			end
		end
	elseif (not (p.dashmode or downslope)) then  -- (FSonic dash)
		p.normalspeed = p.topspeed
	end

	-- Fixing slope physics slightly to
	-- play better with the new speed cap.
	if (downslope) then
		-- MOAR SPEED
		p.normalspeed = $ + ((p.prevz - p.mo.z) * 2 / (p.normalspeed / FRACUNIT))
	end

	-- buffed glide acceleration
	if (p.charability == CA_GLIDEANDCLIMB and p.pflags & PF_THOKKED) then
		if (p.rspeed <= p.maxspeed / 2) then
			p.actionspd = $ + p.glidetime ^ 2 / 20
		end
	else
		p.actionspd = skins[p.mo.skin].actionspd
	end

	-- Metal flies and super players are overpowered,
	-- so they both get souped up acceleration.
	p.thrustfactor = (p.powers[pw_super] or p.mo.skin == "metal_sonic")
			           and 5 or 3

	if (p.mo.skin != "metal_sonic") then  -- Metal does his own thing.
		p.runspeed     = 24*FRACUNIT
		p.accelstart   = 178
		p.acceleration = 48
	end
end

local function ClassicReset (p)
	local de = classic[p.mo.skin]
	local t  = p.classic

	t.momentum   = cvor(cv_momentum,   de.momentum   != false)

	t.nothok     = cvor(cv_nothok,     de.nothok     != false)
	t.spincharge = cvor(cv_spincharge, de.spincharge != false)
	t.droproll   = cvor(cv_droproll,   de.droproll   != false)

	t.animations = cvor(cv_animations, de.animations != false)
	t.fancyrev   = cvor(cv_fancyrev,   de.fancyrev   != false or t.animations)
	t.walkspring = cvor(cv_walkspring, de.walkspring != false or t.animations)
end


-------------------------------------------------------------------------------

local function SubRegister (cvt, ...)
	local t = {}
	local s = { ... }

	local spre = cvt[1] .. "_"
	for i = 1, #s do
		cvt[1] = spre .. s[i]
		t[i]   = CV_RegisterVar(cvt)
	end

	return unpack(t)
end

local CVPV_CLASSIC = { No = 0, Yes = 1, Default = 2 }
local PV_CLASSIC   = { "No", "Yes", "Default", most = "Default" }
local CVPV_REFLEX  = { MIN = FRACUNIT/10, MAX = FRACUNIT/2 }

cv_camadjust = CV_RegisterVar(
{
	"cam_adjust", "Off", CV_SAVE|CV_SHOWMODIF,
	CV_OnOff,
})

cv_classic = CV_RegisterVar(
{
	"classic", "Default", CV_NETVAR,
	CVPV_CLASSIC,
})
cv_momentum,
cv_nothok, cv_spincharge, cv_droproll,
cv_animations, cv_fancyrev, cv_walkspring =
	SubRegister(
	{
		"classic", "Default", CV_NETVAR|CV_CALL|CV_NOINIT,
	   CVPV_CLASSIC,
		function () for p in players.iterate do
			p.classic = nil  -- little hack
		end end
	},
		"momentum",
		"removethok", "spindash", "droproll",
		"animations", "spindash_animation", "spring_animation")

cv_menukey = CV_RegisterVar(
{
	"classic_menubutton", "Custom1", CV_SAVE,
	{ Custom1 = 1, Custom2 = 2, Custom3 = 3, FireNormal = 0, },
})
cv_menuhold, cv_menurepeat =
	SubRegister(
	{
		"classic", "0.5", CV_SAVE|CV_FLOAT,
   	CVPV_REFLEX,
	},
		"menuhold", "menurepeat")

local menu =
{
	{
		{ "Classic Everything", PV_CLASSIC, cv_classic    },
		{ "Physics",            2                         },
		{ "Animations",         3                         },
		{                                                 },
		{
			"Menu Toggle Button",
			{
				"FireNormal", "Custom1", "Custom2", "Custom3",
				most = "FireNormal"
			}, cv_menukey
		},
		{ "Menu Open Hold", CVPV_REFLEX, cv_menuhold   },
		{ "Menu Repeat",    CVPV_REFLEX, cv_menurepeat },
		index = 1
	},
	{
		{ "Momentum",           PV_CLASSIC, cv_momentum   },
		{ "Spindash Charging",  PV_CLASSIC, cv_spincharge },
		{                                                 },
		{ "Remove Thok",        PV_CLASSIC, cv_nothok     },
		{ "Fall and Roll",      PV_CLASSIC, cv_droproll   },
		index = 1
	},
	{
		{ "Animations",         PV_CLASSIC, cv_animations },
		{                                                 },
		{ "Spindash",           PV_CLASSIC, cv_fancyrev   },
		{ "Spring Falling",     PV_CLASSIC, cv_walkspring },
		index = 1
	},
}

-------------------------------------------------------------------------------

-- Table of sectors that are slopes, also by copy.
-- Index by sector number.
rawset(_G, "slopes", {})

addHook("MapLoad", function () for l in lines.iterate do
	if (l.special >= 700) then
		if (l.special <= 705) then
			slopes[#l.frontsector] = l
		elseif (l.special <= 715) then
			slopes[#l.backsector] = l
		elseif (l.special <= 722) then
			for s in sectors.iterate do
				if (s.tag == l.tag) then
					slopes[#s] = l
				end
			end
		end
	end
end end)

-- Implement everything, mostly physics.
addHook("ThinkFrame", function () for p in players.iterate() do
	-- foremost initialization
	if (p.classicmenu == nil) then
		-- We need atleast the menu, so we can turn on Classic again!
		p.classicmenu = {
			active = 0, tics   = FADETICS,
			page   = 1, index  = 1, 
		}
	end

	if (p.prevcmd == nil) then  -- If we have one, we must have others.
		p.prevcmd = { forwardmove = 0, sidemove = 0, buttons = 0 }
		p.spindashframe = 0
		p.spincharges   = 0
		p.prevnormalspeed = p.normalspeed
	end

	if (p.mo and not (p.classicmenu.active
		               or p.cmd.buttons & BT_FIRENORMAL<<cv_menukey.value))
	then
		if (p.prevz == nil) then
			p.prevz = p.mo.z
		end

		if (p.classic) then
			if (not cvor(cv_classic, classic[p.mo.skin])) then
				p.classic = nil
				R_SetPlayerSkin(p, p.mo.skin)
			end
		else
			if (cvor(cv_classic, classic[p.mo.skin])) then
				p.classic = {}
				ClassicReset(p)
				R_SetPlayerSkin(p, p.mo.skin)
			end
		end

		if (p.classic) then
			--      ~TO DO~
			-- Make an options screen to make certain aspects of this WAD
			-- togglable, akin to the level select in Sonic 1/2 mobile ports.
			-- Add abilities from other classic games for Sonic such as
			-- the Insta-Shield, my version of the Drop Dash,
			-- the Super PeelOut (needs running animations), and possibly
			-- with Saph's permission, normal shields replaced with elementals.

			p.rspeed = R_PointToDist2(0, 0, p.rmomx, p.rmomy)

			local onslope = slopes[#p.mo.subsector.sector]
				             and P_IsObjectOnGround(p.mo)

			if (p.classic.nothok and p.charability == CA_THOK) then
				p.charability = CA_NONE  -- Goodbye, Thok..  *sob*
			end

			if (p.classic.momentum and not p.mo.currentaxis) then
				ClassicMomentum(p, onslope)
			end

			if (p.classic.animations) then
				if (p.spinitem == MT_THOK) then
					p.spinitem = MT_NULL  -- Unless you have a custom spintrail,
					                      -- you don't really need one.
				end

				if (p.classic.fancyrev) then
					ClassicSpindashFrames(p)
				end

				if (p.classic.walkspring) then
					if (p.mo.eflags & MFE_SPRUNG) then
						p.sprung = true
					end
					if (p.sprung and p.panim == PA_FALL
						 and not (p.pflags & PF_THOKKED))  -- whirlwind
					then
						p.mo.state = S_PLAY_RUN1
						p.sprung   = false
					end
				end
			end

			if (p.classic.spincharge) then
				p.revitem = MT_NULL
				ClassicSpindash(p)
			end

			if (p.pflags & PF_SPINNING and not P_IsObjectOnGround(p.mo))
			then
				-- Unlock movement by removing PF_SPINNING,
				-- and thus preventing skimming aswell.
				-- PF_JUMPED so the player doesn't take damage while falling.
				p.pflags = $ & ~(PF_SPINNING) | PF_JUMPED
			end

			if (p.classic.droproll and p.charability2 == CA2_SPINDASH
				 and not (p.pflags & PF_SPINNING)
				 and p.cmd.buttons & BT_USE and p.mo.eflags & MFE_JUSTHITFLOOR
				 and p.rspeed > FixedMul(p.mo.scale, 4*FRACUNIT)
				 and not (p.mo.state == S_PLAY_DIE or P_CheckDeathPitCollide(p.mo))
				 and not (p.mo.skin == "dirk" and
				          range(p.mo.state, S_PLAY_ICESURF1, S_PLAY_ICESURF2)))
			then
				p.pflags = $|PF_SPINNING
				p.mo.state = S_PLAY_ATK1  -- standing looks weird
				S_StartSound(p.mo, sfx_spin)
			end

			-- Everyone's Super Sonic, even outside of Match.
			p.charflags = $|SF_SUPER
		end

		-- Camera adjusts while running down slopes.
		--
		-- todo: modify camera directly, so player can keep his custom height.
		if (cv_camadjust.value) then
			if (maptol != TOL_2D
				 and onslope and not (p.mo.eflags & MFE_JUSTHITFLOOR))
			then
				COM_BufInsertText(p, "cam_height " ..  20 + (p.prevz - p.mo.z)
				                                            / FRACUNIT * 3)
			else
				COM_BufInsertText(p, "cam_height 20")
			end
		end

		p.prevz = p.mo.prevz
	end

	-- menu stuff
	-- todo: comments!
	if (p == server or p == admin) then
		local e = p.classicmenu

		if (e.active == MENU_FADEIN) then
			if (e.tics > 0) then
				e.tics = $-1
			else
				e.active = 1
			end
		elseif (e.active == MENU_FADEOUT) then
			if (e.tics < FADETICS) then
				e.tics = $+1
			else
				e.active = 0
				e.tics   = FixedMul(cv_menuhold.value, TICRATE*FRACUNIT)>>FRACBITS

				p.pflags       = $ & ~(PF_FORCESTRAFE)
				p.jumpfactor   = skins[p.mo.skin].jumpfactor
				p.charability2 = skins[p.mo.skin].ability2
			end
		elseif (not e.active) then
			if (p.prevcmd.buttons & BT_FIRENORMAL<<cv_menukey.value) then
				if (p.cmd.buttons & BT_FIRENORMAL<<cv_menukey.value) then
					if (e.tics > 0) then
						e.tics = $-1
					else
						e.active = MENU_FADEIN
						e.tics   = FADETICS
					end

					-- Hacks to disable movement while in the menu.
					p.pflags       = $|PF_FORCESTRAFE
					p.normalspeed  = 0
					p.jumpfactor   = 0
					p.charability2 = CA2_NONE
				else
					e.active = MENU_FADEOUT
					e.tics   = FADETICS
				end
			end
		elseif (p.cmd.buttons & BT_FIRENORMAL<<cv_menukey.value) then
			if (not (p.prevcmd.buttons & BT_FIRENORMAL<<cv_menukey.value)) then
				e.active = MENU_FADEOUT
				e.tics   = 0
			end
		else
			if (e.tics > 0) then
				e.tics = $-1
			end

			if ((p.cmd.forwardmove or p.cmd.sidemove
			  	  or (p.cmd.buttons & (BT_JUMP|BT_USE)))
			 	 and (not (p.prevcmd.forwardmove or p.prevcmd.sidemove
					     	  or (p.prevcmd.buttons & (BT_JUMP|BT_USE)))
						or e.tics == 0))
			then
				local op = menu[e.page][menu[e.page].index]
				-- navigation
				if (p.cmd.buttons & BT_USE) then
					if (e.page != 1) then
						e.page = 1
						S_StartSound(nil, sfx_menu1, p)
					end
				elseif (p.cmd.forwardmove < 0) then
					menu[e.page].index = ($ < #menu[e.page])
					                     and $+((menu[e.page][$+1][1]) and 1 or 2)
					                     or 1
					S_StartSound(nil, sfx_menu1, p)
				elseif (p.cmd.forwardmove > 0) then
					menu[e.page].index = ($ > 1)
					                     and $-((menu[e.page][$-1][1]) and 1 or 2)
					                     or #menu[e.page]
					S_StartSound(nil, sfx_menu1, p)
				elseif (op[3]) then  -- cvar
					-- possiblevalues[value+1] is usually the string value.
					-- Except with MIN and MAX, where it's probably nil.
					local most, least
					if (op[2].MAX) then most  = op[2].MAX else most  = #op[2]-1 end
					if (op[2].MIN) then least = op[2].MIN else least =  0       end

					local n = op[3].value
					if (p.cmd.sidemove > 0 or p.cmd.buttons & BT_JUMP) then
						-- Reverse order because MIN and MAX can be 0.
						n = ($ != most) and $+1 or least
					else
						if (n != least) then n = $-1
						                else n = most end
					end
					setcv(p, op[3], n)
					S_StartSound(nil, sfx_menu1, p)
				else
					if (p.cmd.buttons & BT_JUMP or p.cmd.sidemove > 0) then
						e.page = op[2]
						S_StartSound(nil, sfx_menu1, p)
					end
				end
				e.tics = FixedMul(cv_menurepeat.value, TICRATE*FRACUNIT)>>FRACBITS
			end
		end
	end

	p.prevnormalspeed     = p.normalspeed

	p.prevcmd.forwardmove = p.cmd.forwardmove
	p.prevcmd.sidemove    = p.cmd.sidemove
	p.prevcmd.buttons     = p.cmd.buttons
end end)

local function DrawItems (v, x, y, cat)
	local cw, itw = 0, 0

	for i = 1, #menu[cat] do
		if (menu[cat][i][3]) then
			local w = v.stringWidth(menu[cat][i][1]) + 12
			if (w > cw) then
				cw = w
			end

			if (menu[cat][i][2].most) then
				w = $ + v.stringWidth(menu[cat][i][2].most)
				if (w > itw) then
					itw = w
				end
			end
		end
	end

	local cvx
	itw = x - $ / 2
	cvx = itw + cw

	for i = 1, #menu[cat] do
		if (menu[cat][i][1]) then
			local flags = ((i == menu[cat].index) and V_YELLOWMAP or 0)
			if (menu[cat][i][3]) then
				v.drawString(itw, y, menu[cat][i][1], flags)
				-- CV_MODIFIED isn't enough
				if (menu[cat][i][3].string != menu[cat][i][3].defaultvalue) then
					flags = V_REDMAP
				end
				v.drawString(cvx, y, menu[cat][i][3].string, flags)
			else
				v.drawString(x, y, menu[cat][i][1], flags, "center")
			end
		end

		y = $ + 16
	end
end

hud.add(function (v, p)
	local e = p.classicmenu
	if (e.active > 1) then
		local tics = e.tics
		local first = (tics >= FADETICS/2)
		if (first) then
			tics = $ - FADETICS/2
		end

		local aa = FixedDiv(tics*FRACUNIT,
		                    FixedMul(FADETICS/2*FRACUNIT, FRACUNIT/10))>>FRACBITS
		if (first) then
			V_DrawPatchFill(v, v.cachePatch("~PIT"), aa<<V_ALPHASHIFT)
		else
			V_DrawPatchFill(v, v.cachePatch("~PIT"))
			V_DrawPatchFill(v, v.cachePatch("SRB2BACK"), aa<<V_ALPHASHIFT)
		end
	elseif (e.active) then
		V_DrawPatchFill(v, v.cachePatch("SRB2BACK"))

		DrawItems(v, 160, 100-#menu[e.page]*8, e.page)
	end
end)


-- vim: set ts=3 sw=3 ft=lua :
